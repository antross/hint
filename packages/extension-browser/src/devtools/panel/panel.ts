import browser from '../../shared/browser';
import { mapHeaders } from '../../shared/headers';
import { Config, Events } from '../../shared/types';

import analyzeView from './views/pages/analyze';
import configurationView from './views/pages/configuration';
import resultsView from './views/pages/results';

import './panel.css';

const tabId = browser.devtools.inspectedWindow.tabId;
const port = browser.runtime.connect({ name: `${tabId}` });

const sendMessage = (message: Events) => {
    browser.runtime.sendMessage(message);
};

const hops = new Map<string, string[]>();

/**
 * Generate `fetch::end` events from `devtools.network.onRequestFinished`.
 * These are forwarded to the content-script via the background-script.
 *
 * Note: `fetch::start` events are generated by the background-script
 * using the `webRequest` APIs (as `devtools.network` does not have an
 * equivalent event).
 */
const onRequestFinished = (request: chrome.devtools.network.Request) => {
    request.getContent((content: string) => {
        const url = request.request.url;

        if (request.response.redirectURL) {

            // Track hops on a redirect.
            const urls = hops.has(url) ? hops.get(url)! : [];

            urls.push(url);
            hops.delete(url);
            hops.set(request.response.redirectURL, urls);

        } else {

            // Otherwise generate a `fetch::end`.
            sendMessage({
                fetchEnd: {
                    element: null,
                    request: {
                        headers: mapHeaders(request.request.headers),
                        url: request.request.url
                    },
                    resource: request.request.url,
                    response: {
                        body: {
                            content,
                            rawContent: null as any,
                            rawResponse: null as any
                        },
                        charset: '', // Set by `content-script/connector`.
                        headers: mapHeaders(request.response.headers),
                        hops: hops.get(url) || [],
                        mediaType: '', // Set by `content-script/connector`.
                        statusCode: request.response.status,
                        url: request.request.url
                    }
                }
            });
        }

        hops.delete(url);
    });
};

const render = (fragment: DocumentFragment) => {
    document.body.textContent = '';
    document.body.appendChild(fragment);
};

const onCancel = () => {
    sendMessage({ done: true, tabId });

    browser.devtools.network.onRequestFinished.removeListener(onRequestFinished);

    render(configurationView({ onAnalyzeClick: onStart })); // eslint-disable-line
};

const onStart = (config: Config) => {
    sendMessage({ enable: config, tabId });

    browser.devtools.network.onRequestFinished.addListener(onRequestFinished);

    render(analyzeView({ onCancelClick: onCancel }));
};

port.onMessage.addListener((message: Events) => {
    if (message.results) {
        browser.devtools.network.onRequestFinished.removeListener(onRequestFinished);

        render(resultsView({onRestartClick: onCancel, results: message.results}));
    }
});

// Start in the stopped state (on the "Configuration" page).
onCancel();
